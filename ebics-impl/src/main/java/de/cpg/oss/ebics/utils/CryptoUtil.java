package de.cpg.oss.ebics.utils;

import de.cpg.oss.ebics.api.EbicsSignatureKey;
import de.cpg.oss.ebics.api.exception.EbicsException;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.binary.Base64;
import org.bouncycastle.asn1.nist.NISTObjectIdentifiers;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.DigestInfo;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.IOException;
import java.io.InputStream;
import java.security.*;


/**
 * Some utilities for EBICS request creation and reception
 *
 * @author hachani
 */
@Slf4j
public abstract class CryptoUtil {

    private static final String EBICS_RSA_ALGORITHM = "RSA/ECB/PKCS1Padding";
    private static final String EBICS_AES_ALGORITHM = "AES/CBC/ISO10126Padding";
    public static final String EBICS_DIGEST_ALGORITHM = "SHA-256";

    /**
     * Generates a random nonce.
     * <p>
     * <p>EBICS Specification 2.4.2 - 11.6 Generation of the transaction IDs:
     * <p>
     * <p>Transaction IDs are cryptographically-strong random numbers with a length of 128 bits. This
     * means that the likelihood of any two bank systems using the same transaction ID at the
     * same time is sufficiently small.
     * <p>
     * <p>Transaction IDs are generated by cryptographic pseudo-random number generators (PRNG)
     * that have been initialized with a real random number (seed). The entropy of the seed should
     * be at least 100 bits.
     *
     * @return a random nonce.
     */
    public static byte[] generateNonce() {
        return secureRandom().generateSeed(16);
    }

    /**
     * Encrypts an input with a given key spec.
     * <p>
     * <p>EBICS Specification 2.4.2 - 15.1 Workflows at the sender’s end:
     * <p>
     * <p><b>Preparation for DEK encryption</b>
     * <p>The 128 bit DEK that is interpreted as a natural number is filled out with null bits to 768 bits in
     * front of the highest-value bit. The result is called PDEK.
     * <p>
     * <p><b>Encryption of the secret DES key</b>
     * <p>PDEK is then encrypted with the recipient’s public key of the RSA key system and is then
     * expanded with leading null bits to 1024 bits.
     * <p>The result is called EDEK. It must be ensured that EDEK is not equal to DEK.
     * <p>
     * <p><b>Encryption of the messages</b>
     * <p><U>Padding of the message:</U>
     * <p>The method Padding with Octets in accordance with ANSI X9.23 is used for padding the
     * message, i.e. in all cases, data is appended to the message that is to be encrypted.
     * <p>
     * <p><U>Application of the encryption algorithm:</U>
     * <p>The message is encrypted in CBC mode in accordance with ANSI X3.106 with the secret key
     * DEK according to the 2-key triple DES process as specified in ANSI X3.92-1981.
     * <p>In doing this, the following initialization value “ICV” is used: X ‘00 00 00 00 00 00 00 00’.
     *
     * @param inputStream the input to encrypt
     * @param aesKey      the AES symmetric key
     * @return the encrypted input
     */
    public static InputStream encryptAES(final InputStream inputStream, final byte[] aesKey) {
        return encryptOrDecryptAES(Cipher.ENCRYPT_MODE, inputStream, aesKey);
    }

    /**
     * Decrypts the <code>encryptedData</code> using the decoded transaction key.
     * <p>
     * <p>EBICS Specification 2.4.2 - 15.2 Workflows at the recipient’s end:
     * <p>
     * <p><b>Decryption of the message</b>
     * <p>The encrypted original message is decrypted in CBC mode in accordance with the 2-key
     * triple DES process via the secret DES key (comprising DEK<SUB>left</SUB> and DEK<SUP>right<SUB>).
     * In doing this, the following initialization value ICV is again used.
     * <p>
     * <p><b>Removal of the padding information</b>
     * <p>The method “Padding with Octets” according to ANSI X9.23 is used to remove the padding
     * information from the decrypted message. The original message is then available in decrypted
     * form.
     *
     * @param inputStream The encrypted data
     * @param aesKey      The secret key.
     * @return The decrypted data sent from the EBICS bank.
     */
    public static InputStream decryptAES(final InputStream inputStream, final byte[] aesKey) {
        return encryptOrDecryptAES(Cipher.DECRYPT_MODE, inputStream, aesKey);
    }

    /**
     * Encrypts or decrypts the given input according to key spec.
     *
     * @param mode        the encryption-decryption mode.
     * @param inputStream the input to encrypt or decrypt.
     * @param aesKey      the AES symmetric key
     * @return the encrypted or decrypted data.
     */
    private static InputStream encryptOrDecryptAES(final int mode, final InputStream inputStream, final byte[] aesKey) {
        try {
            final IvParameterSpec ivParameterSpec = new IvParameterSpec(new byte[16]);
            final Cipher cipher = Cipher.getInstance(EBICS_AES_ALGORITHM);
            cipher.init(mode, new SecretKeySpec(aesKey, "AES"), ivParameterSpec);
            return new CipherInputStream(inputStream, cipher);
        } catch (final GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Generates a random password
     *
     * @return the password
     */
    public static String generatePassword() {
        final String pwd = Base64.encodeBase64String(secureRandom().generateSeed(5));
        return pwd.substring(0, pwd.length() - 2);
    }

    /**
     * EBICS Specification 2.4.2 - 11.1.1 Process:
     * <p>
     * <p>Identification and authentication signatures are based on the RSA signature process.
     * The following parameters determine the identification and authentication signature process:
     * <p>
     * <ol>
     * <li> Length of the (secret) RSA key
     * <li> Hash algorithm
     * <li> Padding process
     * <li> Canonisation process.
     * </ol>
     * <p>
     * <p>For the identification and authentication process, EBICS defines the process “X002” with
     * the following parameters:
     * <ol>
     * <li>Key length in Kbit >=1Kbit (1024 bit) and lesser than 16Kbit</li>
     * <li>Hash algorithm SHA-256</li>
     * <li>Padding process: PKCS#1</li>
     * <li>Canonisation process: http://www.w3.org/TR/2001/REC-xml-c14n-20010315
     * </ol>
     * <p>
     * <p>From EBICS 2.4 on, the customer system must use the hash value of the public bank key
     * X002 in a request.
     * <p>
     * <p>Notes:
     * <ol>
     * <li> The key length is defined else where.
     * <li> The padding is performed by the {@link Signature} class.
     * <li> The digest must be already canonized
     * </ol>
     */
    static byte[] authenticate(final byte[] message, final PrivateKey authenticationKey) throws GeneralSecurityException {
        final Signature signature = Signature.getInstance("SHA256withRSA");
        signature.initSign(authenticationKey);
        signature.update(message);
        return signature.sign();
    }

    /**
     * EBICS Specification 2.4.2 - 14.1 Version A005/A006 of the electronic signature:
     * <p>
     * <p>For the signature processes A005 an interval of 1536 bit (minimum)
     * and 4096 bit (maximum) is defined for the key length.
     * <p>
     * <p>The digital signature mechanisms A005 is both based on the industry standard
     * [PKCS1] using the hash algorithm SHA-256. They are both signature mechanisms without
     * message recovery.
     * <p>
     * <p>A hash algorithm maps bit sequences of arbitrary length (input bit sequences) to byte
     * sequences of a fixed length, determined by the Hash algorithm. The result of the execution of
     * a Hash algorithm to a bit sequence is defined as hash value.
     * <p>
     * <p>The hash algorithm SHA-256 is specified in [FIPS H2]. SHA-256 maps input bit sequences of
     * arbitrary length to byte sequences of 32 byte length. The padding of input bit sequences to a
     * length being a multiple of 64 byte is part of the hash algorithm. The padding even is applied if
     * the input bit sequence already has a length that is a multiple of 64 byte.
     * <p>
     * <p>SHA-256 processes the input bit sequences in blocks of 64 byte length.
     * The hash value of a bit sequence x under the hash algorithm SHA-256 is referred to as
     * follows: SHA-256(x).
     * <p>
     * <p>The digital signature mechanism A005 is identical to EMSA-PKCS1-v1_5 using the hash
     * algorithm SHA-256. The byte length H of the hash value is 32.
     * <p>
     * According [PKCS1] (using the method EMSA-PKCS1-v1_5) the following steps shall be
     * performed for the computation of a signature for message M with bit length m.
     * <ol>
     * <li> The hash value HASH(M) of the byte length H shall be computed. In the case of A005
     * SHA-256(M) with a length of 32 bytes.</li>
     * <li> The DSI for the signature algorithm shall be generated.</li>
     * <li> A signature shall be computed using the DSI with the standard algorithm for the
     * signature generation described in section 14.1.3.1 of the EBICS specification (V 2.4.2).
     * </ol>
     * <p>
     * <p>The {@link Signature} is a digital signature scheme with
     * appendix (SSA) combining the RSA algorithm with the EMSA-PKCS1-v1_5 encoding
     * method.
     * <p>
     * <p> The {@code digest} will be signed with the RSA user signature key using the
     * {@link Signature} that will be instantiated with the <b>SHA-256</b>
     * algorithm. This signature is then put in a UserSignature XML object that will be sent to the EBICS server.
     */
    public static byte[] signMessage(final InputStream message, final EbicsSignatureKey signatureKey) throws GeneralSecurityException, IOException {
        final MessageDigest digester = MessageDigest.getInstance(EBICS_DIGEST_ALGORITHM);
        IOUtil.read(digest(message, digester));
        return signHash(digester.digest(), signatureKey);
    }

    public static InputStream digest(final InputStream inputStream, final MessageDigest digester) {
        return new DigestInputStream(removeOSSpecificChars(inputStream), digester);
    }

    public static byte[] signHash(final byte[] sha256Hash, final EbicsSignatureKey signatureKey) throws GeneralSecurityException, IOException {
        final Signature signature;
        switch (signatureKey.getSignatureVersion()) {
            case A005:
                /* Signature.getInstance("SHA256withRSA") also encapsulates message into an ASN.1 object in advance.
                 * Signature.getInstance("RSA") does this not, so it has to be done manually here.
                 * Background: We need to be able to do the SHA-256 calculation and signature creation in two steps
                 * for VEU
                 */
                final AlgorithmIdentifier sha256Aid = new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha256, null);
                final DigestInfo digestInfo = new DigestInfo(sha256Aid, sha256Hash);
                signature = Signature.getInstance("RSA");
                signature.initSign(signatureKey.getPrivateKey());
                signature.update(digestInfo.toASN1Primitive().getEncoded());
                return signature.sign();

            default:
            case A006:
                /* According to EBICS V2.5 spec the SHA-256 hash is hashed via SHA-256 again if signature version A006
                 * is used
                 */
                signature = Signature.getInstance("SHA256withRSAandMGF1", BouncyCastleProvider.PROVIDER_NAME);
                signature.initSign(signatureKey.getPrivateKey());
                signature.update(sha256Hash);
                return signature.sign();
        }
    }

    /**
     * EBICS Specification 14 Appendix: Signature process for the electronic signature:
     * <p></p>
     * <p>The characters restricted to the operating system (CR, LF and Ctrl-Z) are not included in the calculation
     * of hash values of the A005/A006 ES (analogous to A004 ES).</p>
     *
     * @param octet the byte
     * @return <code>true</code> if the octet reflects an OS specific character
     */
    static boolean isOsSpecificChar(final byte octet) {
        switch (octet) {
            case '\r': // CR
            case '\n': // LF
            case 0x1A: // CTRL-Z / EOF
                return true;

            default:
                return false;
        }
    }

    private static InputStream removeOSSpecificChars(final InputStream inputStream) {
        return new InputStream() {
            @Override
            public int read() throws IOException {
                do {
                    final byte next = (byte) inputStream.read();
                    if (!isOsSpecificChar(next)) {
                        return next;
                    }
                } while (true);
            }
        };
    }

    public static byte[] encryptRSA(final byte[] input, final PublicKey encryptionKey) throws EbicsException {
        try {
            final Cipher cipher = Cipher.getInstance(EBICS_RSA_ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, encryptionKey);
            return cipher.doFinal(input);
        } catch (final GeneralSecurityException e) {
            throw new EbicsException(e);
        }
    }

    public static byte[] decryptRSA(final byte[] input, final PrivateKey privateKey) throws EbicsException {
        try {
            final Cipher cipher = Cipher.getInstance(EBICS_RSA_ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
            return cipher.doFinal(input);
        } catch (final GeneralSecurityException e) {
            throw new EbicsException(e);
        }
    }

    private static SecureRandom secureRandom() {
        try {
            return SecureRandom.getInstance("SHA1PRNG");
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}
