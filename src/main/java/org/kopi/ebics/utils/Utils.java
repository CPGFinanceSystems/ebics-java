/*
 * Copyright (c) 1990-2012 kopiLeft Development SARL, Bizerte, Tunisia
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * $Id$
 */

package org.kopi.ebics.utils;

import org.apache.http.HttpStatus;
import org.kopi.ebics.exception.EbicsException;
import org.kopi.ebics.messages.Messages;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.zip.DataFormatException;
import java.util.zip.Deflater;
import java.util.zip.Inflater;


/**
 * Some utilities for EBICS request creation and reception
 *
 * @author hachani
 */
public class Utils {

    /**
     * Generates a random nonce.
     * <p>
     * <p>EBICS Specification 2.4.2 - 11.6 Generation of the transaction IDs:
     * <p>
     * <p>Transaction IDs are cryptographically-strong random numbers with a length of 128 bits. This
     * means that the likelihood of any two bank systems using the same transaction ID at the
     * same time is sufficiently small.
     * <p>
     * <p>Transaction IDs are generated by cryptographic pseudo-random number generators (PRNG)
     * that have been initialized with a real random number (seed). The entropy of the seed should
     * be at least 100 bits.
     *
     * @return a random nonce.
     */
    public static byte[] generateNonce() {
        try {
            return SecureRandom.getInstance("SHA1PRNG").generateSeed(16);
        } catch (final NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Encrypts an input with a given key spec.
     * <p>
     * <p>EBICS Specification 2.4.2 - 15.1 Workflows at the sender’s end:
     * <p>
     * <p><b>Preparation for DEK encryption</b>
     * <p>The 128 bit DEK that is interpreted as a natural number is filled out with null bits to 768 bits in
     * front of the highest-value bit. The result is called PDEK.
     * <p>
     * <p><b>Encryption of the secret DES key</b>
     * <p>PDEK is then encrypted with the recipient’s public key of the RSA key system and is then
     * expanded with leading null bits to 1024 bits.
     * <p>The result is called EDEK. It must be ensured that EDEK is not equal to DEK.
     * <p>
     * <p><b>Encryption of the messages</b>
     * <p><U>Padding of the message:</U>
     * <p>The method Padding with Octets in accordance with ANSI X9.23 is used for padding the
     * message, i.e. in all cases, data is appended to the message that is to be encrypted.
     * <p>
     * <p><U>Application of the encryption algorithm:</U>
     * <p>The message is encrypted in CBC mode in accordance with ANSI X3.106 with the secret key
     * DEK according to the 2-key triple DES process as specified in ANSI X3.92-1981.
     * <p>In doing this, the following initialization value “ICV” is used: X ‘00 00 00 00 00 00 00 00’.
     *
     * @param input   the input to encrypt
     * @param keySpec the key spec
     * @return the encrypted input
     */
    public static byte[] encrypt(final byte[] input, final SecretKeySpec keySpec)
            throws EbicsException {
        return encryptOrDecrypt(Cipher.ENCRYPT_MODE, input, keySpec);
    }

    /**
     * Decrypts the given input according to key spec.
     *
     * @param input   the input to decrypt
     * @param keySpec the key spec
     * @return the decrypted input
     */
    public static byte[] decrypt(final byte[] input, final SecretKeySpec keySpec)
            throws EbicsException {
        return encryptOrDecrypt(Cipher.DECRYPT_MODE, input, keySpec);
    }

    /**
     * Encrypts or decrypts the given input according to key spec.
     *
     * @param mode    the encryption-decryption mode.
     * @param input   the input to encrypt or decrypt.
     * @param keySpec the key spec.
     * @return the encrypted or decrypted data.
     */
    private static byte[] encryptOrDecrypt(final int mode, final byte[] input, final SecretKeySpec keySpec) {
        final IvParameterSpec iv;
        final Cipher cipher;

        iv = new IvParameterSpec(new byte[16]);
        try {
            cipher = Cipher.getInstance("AES/CBC/ISO10126Padding");
            cipher.init(mode, keySpec, iv);
            return cipher.doFinal(input);
        } catch (final GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Checks for the returned http code
     *
     * @param httpCode the http code
     */
    public static void checkHttpCode(final int httpCode) throws EbicsException {
        if (httpCode != HttpStatus.SC_OK) {
            throw new EbicsException(Messages.getString("http.code.error",
                    Constants.APPLICATION_BUNDLE_NAME,
                    httpCode));
        }
    }
}
